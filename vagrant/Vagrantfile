# -*- mode: ruby -*-
# vi: set ft=ruby :
#
# voip-stack Vagrantfile
#
# Creates 3 VMs for VoIP infrastructure using vagrant-qemu on Apple Silicon:
#   - sip-1:   OpenSIPS SIP Proxy (192.168.64.10)
#   - pbx-1:   Asterisk PBX (192.168.64.30)
#   - media-1: RTPEngine Media Proxy (192.168.64.20)
#
# Prerequisites:
#   brew install qemu
#   brew install --cask vagrant
#   vagrant plugin install vagrant-qemu
#
# Usage:
#   vagrant up              # Start all VMs
#   vagrant up sip-1        # Start specific VM
#   vagrant ssh sip-1       # SSH into VM
#   vagrant provision       # Run Ansible provisioner
#   vagrant destroy -f      # Destroy all VMs
#   vagrant snapshot push   # Create snapshots
#   vagrant snapshot pop    # Restore snapshots
#

# Minimum Vagrant version required
Vagrant.require_version ">= 2.3.0"

# VM Configuration
# Using generic/debian12 ARM64 for vagrant-qemu on Apple Silicon
VM_BOX = "generic/debian12"
VM_BOX_VERSION = "4.3.12"

# Network Configuration
# Note: vagrant-qemu uses QEMU's user-mode networking by default
# We configure private_network for VM-to-VM and host-to-VM communication
NETWORK_PREFIX = "192.168.64"
GATEWAY = "192.168.64.1"

# VM Definitions
# Each VM needs a unique ssh_port to avoid port collisions with vagrant-qemu
VMS = {
  "sip-1" => {
    ip: "#{NETWORK_PREFIX}.10",
    memory: 2048,
    cpus: 2,
    ssh_port: 52222,
    role: "sip_proxy",
    description: "OpenSIPS SIP Proxy",
    ansible_groups: ["sip_proxies", "voip"]
  },
  "media-1" => {
    ip: "#{NETWORK_PREFIX}.20",
    memory: 4096,
    cpus: 4,
    ssh_port: 52223,
    role: "media",
    description: "RTPEngine Media Proxy",
    ansible_groups: ["media_servers", "voip"]
  },
  "pbx-1" => {
    ip: "#{NETWORK_PREFIX}.30",
    memory: 4096,
    cpus: 2,
    ssh_port: 52224,
    role: "pbx",
    description: "Asterisk PBX",
    ansible_groups: ["pbx", "voip"]
  }
}

# DevStack Core host IP (Mac host running Docker services)
DEVSTACK_HOST = "192.168.64.1"

Vagrant.configure("2") do |config|
  # Common box configuration
  config.vm.box = VM_BOX
  config.vm.box_version = VM_BOX_VERSION

  # SSH configuration
  config.ssh.insert_key = true
  config.ssh.forward_agent = true

  # Increase boot timeout for QEMU VMs (can be slow on first boot)
  config.vm.boot_timeout = 1200

  # Disable default synced folder (use Ansible for file transfers)
  config.vm.synced_folder ".", "/vagrant", disabled: true

  # Define each VM
  VMS.each do |vm_name, vm_config|
    config.vm.define vm_name do |vm|
      vm.vm.hostname = vm_name

      # Private network for VM communication
      vm.vm.network "private_network",
        ip: vm_config[:ip],
        netmask: "255.255.255.0"

      # QEMU provider configuration
      # Uses recommended settings for Apple Silicon/ARM64 with HVF acceleration
      vm.vm.provider "qemu" do |qe|
        qe.memory = vm_config[:memory].to_s
        qe.smp = vm_config[:cpus].to_s
        qe.arch = "aarch64"
        qe.machine = "virt,accel=hvf,highmem=off"
        qe.cpu = "host"
        qe.net_device = "virtio-net-pci"

        # Unique SSH port for each VM to avoid collisions
        qe.ssh_port = vm_config[:ssh_port]
      end

      # VM-specific provisioning message
      vm.vm.provision "shell", inline: <<-SHELL
        echo "=== Provisioning #{vm_name} (#{vm_config[:description]}) ==="
        echo "IP Address: #{vm_config[:ip]}"
        echo "Role: #{vm_config[:role]}"
        echo "DevStack Core: #{DEVSTACK_HOST}"

        # Configure /etc/hosts for DevStack Core access
        grep -q "devstack" /etc/hosts || echo "#{DEVSTACK_HOST} devstack devstack.local" >> /etc/hosts

        # Install essential packages
        apt-get update -qq
        apt-get install -y -qq curl wget vim htop net-tools dnsutils

        # Verify network connectivity to DevStack Core
        echo "Testing connectivity to DevStack Core..."
        curl -s --connect-timeout 5 http://#{DEVSTACK_HOST}:8200/v1/sys/health || echo "Note: Vault not reachable (may need to start DevStack Core)"

        echo "=== Base provisioning complete for #{vm_name} ==="
      SHELL

      # Ansible provisioner (runs after all VMs are up when using --provision)
      # Only configure on the last VM to run once for all
      if vm_name == VMS.keys.last
        vm.vm.provision "ansible" do |ansible|
          ansible.playbook = "../ansible/playbooks/provision-vms.yml"
          ansible.inventory_path = "../ansible/inventory/vagrant.yml"
          ansible.limit = "all"
          ansible.compatibility_mode = "2.0"

          # Ansible configuration
          ansible.extra_vars = {
            ansible_python_interpreter: "/usr/bin/python3",
            devstack_host: DEVSTACK_HOST,
            vault_addr: "http://#{DEVSTACK_HOST}:8200"
          }

          # Group configuration for Ansible inventory
          ansible.groups = {
            "sip_proxies" => ["sip-1"],
            "media_servers" => ["media-1"],
            "pbx" => ["pbx-1"],
            "voip:children" => ["sip_proxies", "media_servers", "pbx"]
          }

          # Enable verbose output with ANSIBLE_VERBOSE=1
          ansible.verbose = ENV['ANSIBLE_VERBOSE'] ? "vv" : false
        end
      end
    end
  end

  # Post-up message
  config.vm.post_up_message = <<-MSG
  ============================================
  voip-stack VMs are ready!
  ============================================

  VMs:
    sip-1:   #{VMS["sip-1"][:ip]} (OpenSIPS)
    media-1: #{VMS["media-1"][:ip]} (RTPEngine)
    pbx-1:   #{VMS["pbx-1"][:ip]} (Asterisk)

  SSH Access:
    vagrant ssh sip-1
    vagrant ssh media-1
    vagrant ssh pbx-1

  Or directly:
    ssh vagrant@#{VMS["sip-1"][:ip]}
    ssh vagrant@#{VMS["media-1"][:ip]}
    ssh vagrant@#{VMS["pbx-1"][:ip]}

  Run Ansible provisioning:
    vagrant provision

  DevStack Core should be running at #{DEVSTACK_HOST}
  ============================================
  MSG
end
